#!/bin/bash

########################################################################
#   airtools-cli [-h] [-p projectdir] [-s setname] <task> [parameters]
#
#   AIRTOOLS Tasks CLI
#   note: the following environment variables may be used
#       AO_FLATS in _flats
#       AO_LIGHT in _lights
#       AO_BGVAR in _bgvar
#       AO_REGIS in _register
#       AO_STACK in _stack and _costack
#       AO_AMASK and AO_ACCOO in _astrometry
#
########################################################################
VERSION="1.0"
VINFO="T. Lehmann, Aug. 2019"
PINFO="\
    options:
      -h            show this help text
      -p projectdir start from projectdir (default: cwd) 
      -s setname    limit processing to given image set
      -c cmd        run the given user command
      -m mode       control task operation (execute limited code blocks)
      -o            overwrite previous results without warning
      -q            lower amount of output messages
    parameters:
      task          run given task    
"
CHANGELOG="
    1.0   - 16 Aug 2019
        * register: bugfix: correctly capture exit code of the first comand in
            a pipe
        * load_images: deal with setname used as parameter

    1.0a5 - 17 Jun 2019
        * added ds9cmd wrapper for comet extraction tasks

    1.0a4 - 15 May 2019
        * imageinfo: enhanced to support newer naming scheme of fits files
        * load_stacks: wait for images to be loaded
        * new task: ds9cmd

    1.0a3 - 24 Apr 2019
        * bgvar: bugfix: corrected typo in plot filename
        * new task: load_images

    1.0a2 - 01 Mar 2019
        * lights: allow to overwrite default parameters passed to AIccd by
            setting AO_LIGHT
        * allow to use space or comma separated image set names in -s <setname>

    1.0a1 - 31 Jan 2019
        * register: if registration fails on some images then start a second pass
            using more relaxed constraints on allowed offsets
            
    0.9 - 04 Jan 2019
        * bgvar: changed default background fitting in AIbgdiff from surface fit
            to a plane for better stability in case of large offsets between
            images where extended bright sources are in the field of view
        * darks: by default run stats for new images only,
            use AI_EXCLUDE to discard images

    0.9a1 - 03 Dec 2018
        * bgvar, stack, costack: increased bgzero from 3000 to 10000

    0.8 - 29 Oct 2018
        * task darks: create noise image for larger sets (n>=15)
        * task bgvar: recognize option AO_BGVAR
        * task register: recognize option AO_REGIS
        * rename task coextract to load_stacks
        * remove hard-coded expansion of PATH variable

    0.7 - 09 Oct 2018
        * stack: stack properties: do not touch header file if all keywords
            are existing already
        * astrometry: rename wcs header file in case of failure of AIwcs
    
    0.6 - 30 Aug 2018
        * added task coextract
        * task stack: estimate noise in green channel and write AI_RMSG
            header keyword
        * task astrometry: allow to mask region for source detections by
            using env variable AO_AMASK which may point to a region file or
            holds the max distance (pixel) of valid objects from image center 

    0.5 - 26 Jun 2018
        * rework handling of AI_CCDREGION
        * added option -m <mode> to limit execution blocks of tasks
        * added option -c <cmd> to execute user defined command

    0.4 - 05 Jun 2018
        * added option -q to reduce output messages

    0.3 - 29 May 2018
        * allow for selection of a specific light image set via -s option

    0.2.1 - 28 May 2018
        * added keywords AI_TELID, BINNING to header file of stack
        * write rounded values of AI_BGG, AI_FWHM
        
    0.2 - 27 May 2018
        * added task status
        * added/improved various messages
        * write OBJECT keyword according to set.dat

    0.1 - 20 May 2018
        * initial version
"


#--------------------
#   user definitions
#--------------------
# Log file
log=airtools.log
# resources file (predefined variables, e.g. day, AI_SITE)
rcfile=.airtoolsrc


#--------------------
#   functions
#--------------------
shorthelp ()
{
    echo "usage: $(basename $0) [-h] [-p projectdir] [-m mode] [-o] <task> [params]"
}

longhelp ()
{
    echo $(basename $0)"   $VERSION   $VINFO"
    shorthelp
    printf "$PINFO"
}

error ()
{
    f_str="$1"
    echo "ERROR:  $f_str" >&2
    exit 1
}

is_equal () {
    # compare two (float) numbers
    local x=$1
    local y=$2
    test $# -ne 2 && echo "ERROR: two parameters required" >&2 && return 255
    local err
    err=$(echo $x $y | awk '{
        d=$1-$2; if (d == 0) {print 0} else {print 255}
    }')
    return $err
}

is_time () {
    local x=$1
    local err
    err=$(echo $x | awk -F ':' '{
        x=0
        if (NF!=2) x=255
        if ($1!~/^[0-9][0-9]$/ || $2!~/^[0-9][0-9]$/) x=255
        if ($1>24 || $2>59) x=255
        print x
    }')
    return $err
}

select_item () {
    # prepend "^" to item string
    local list="$1"
    local item="$2"
    local sep=";"
    echo "$list" | awk -v s="$sep" -v x="$item" '{
        n=split($0,a,s)
        for (i=1;i<=n;i++) {
            sub(/\^/,"",a[i])
            if(i>1) printf("%s", s)
            if(a[i]==x) printf("^")
            printf("%s", a[i])
        }}'
}


#--------------------------------
#   test tasks
#--------------------------------
_setinfo () {
    local retval
    AIsetinfo
    retval=$?
    echo "... done"
    return $retval
}

_minute () {
    local i
    date
    for i in $(seq 6 -1 1)
    do
        echo "# Sleeping $((i*10))s ..."
        sleep 10
    done
    echo "... done"
    return 0
}

_endless () {
    while true
    do
        echo "# Sleeping 10s ..."
        sleep 10
    done
    echo "... done"
    return 0
}

_failure () {
    echo "# Failing in 20s ..."
    sleep 10
    for i in $(seq 10 -1 1)
    do
        echo "# Failing in ${i}s ..."
        sleep 1
    done
    echo "... done"
    return 255
}

_pipetest () {
    local retval=0
    echo "# running pipetest ..."
    __mytest () {
        local infile="$1"
        local tmp1=$(mktemp "/tmp/tmp1_stdin_XXXXXX")
        if [ "$infile" == "-" ]
        then
            cat > $tmp1
            infile=$tmp1
        fi
        sleep 2
        rm -f $tmp1
    }
    for i in $(seq 1 10)
    do
        echo "$i"
        cat /var/log/messages | __mytest -
        test $? -ne 0 && echo "ERROR" && retval=255
    done
    return $retval
}

_sexselect () {
    local retval=0
    local head=test.wcs.ahead
    local sdat=measure/0005.src.dat
    echo "# running sexselect ..."
    __mytest () {
        cat $sdat | sexselect -f - "" 0.02 | \
            addldacwcs - $head > x.fits
        sexselect $sdat "" "" 300 | LANG=C sort -n -k7,7 | \
            grep -v "^#" | head -100 > x.xyref
        head x.xyref
    }
    for i in $(seq 1 10)
    do
        echo "$i"
        __mytest | tee -a x.dat
        test $? -ne 0 && echo "ERROR" && retval=255
    done
    return $retval
}

_test () {
    #_pipetest
    _sexselect
}



#--------------------------------
#   main imred reduction tasks
#--------------------------------
_imageinfo () {
    # DSLR RAW images: must be placed in $AI_RAWDIR, image number is part of file name
    # FITS images: placed in any subdir of $AI_RAWDIR, arbitrary file names
    local extlist
    local ext
    local msg
    local flist
    
    msg="# Collecting image information ..."
    extlist=$(cd $AI_RAWDIR/ && find * -type f | sed -e 's,.*\.,,' | sort -u | \
            grep -iwE "pef|cr2|nef|raf")
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") &&
    echo $msg && if [ "$extlist" ]
    then
        # scanning dslr raw images ...
        # note: use AI_TZOFF=1 if DSLR camera time is MEZ instead of UT
        #   DSLR camera exif time is exposure end time + 30s
        test -f exif.dat && rm exif.dat
        for ext in $extlist
        do
            echo "# scanning $ext files ..."
            img_info $(find $AI_RAWDIR -type f -name "*.$ext") | sort -n -k 2,2 >> exif.dat
            test $? -ne 0 && return 255
        done
    else
        # scanning FITS images ...
        if grep -iq iTelescope.Net $AI_RAWDIR/2*{txt,log} 2>/dev/null
        then
            if [ -e $AI_RAWDIR/obs.txt ]
            then
                itel2obs
            else
                itel2obs | tee -a $AI_RAWDIR/obs.txt
            fi
            tellist=$(get_itel_telid $AI_RAWDIR/2*)
            test "$tellist" && for tel in $tellist
            do
                # bugfix for wrong identifiers on T16
                test $tel == "16" && tel=T16
                test $tel == "jbl08" && tel=T68
                echo "# scanning fits files for $tel ..."
                flist=$(find $AI_RAWDIR \( -name "*fit.zip" -or -name "*fits" \) -not -name "calib*" | grep -iw $tel)
                map_rawfiles -x $flist >> rawfiles.dat
                test $? -ne 0 && return 255
            done
        else
            echo "# scanning fits files ..."
            map_rawfiles -x $(find $AI_RAWDIR -type f \
                   -name "*.fit"  -o -name "*.FIT" \
                -o -name "*.fits" -o -name "*.FITS") >> rawfiles.dat
            test $? -ne 0 && return 255
        fi
    fi
    test -f exif.dat && mousepad exif.dat &
    test -f rawfiles.dat && mousepad rawfiles.dat &
    return 0
}

_darks () {
    # use AI_EXCLUDE to skip some images from master dark
    # TODO: make dkmn a temp file
    #       compute stats only for new images
    #       determine dark varition only for new sets
    local slist
    local dklist
    local set
    local scale
    local flip
    local opts
    local nlist
    local exlist
    local fname
    
    slist=$(AIsetinfo -b | awk '{if($4=="d"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    # checking valid telid
    for set in $slist
    do
        get_param camera.dat pixscale $set > /dev/null
        test $? -ne 0 &&
            echo "ERROR: unknown telescope identifier for set $set." >&2 &&
            return 255
    done
    
    msg="# Computing statistics of dark images ..."
    if [ -z "$TASKMODE" ] || [ "$TASKMODE" == "nodisplay" ]
    then
        for set in $slist
        do
            nlist="$(echo $(AI_EXCLUDE="" AIimlist -n $set "" raw))"
            exlist=""
            for num in $nlist
            do
                fname=$(get_rawfile $num)
                test -s mstat.dk.dat &&
                    grep -q "^$(basename $fname) " mstat.dk.dat &&
                    exlist="$(echo $exlist $num)"
            done
            test "$nlist" == "$exlist" && continue
            test "$msg" && echo $msg && msg=""
            AI_EXCLUDE="$exlist" AImstat -v -c $set >> mstat.dk.dat
        done
    fi
    test ! -s mstat.dk.dat && return 255
    test "$TASKMODE" != "nodisplay" &&
        AIplot -o $AI_TMPDIR/x.darkvalue.png -t "Dark value per image" -p mstat.dk.dat 2 5

    msg="# Creating Master darks ..."
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for set in $slist
    do
        # if necessary add option -r to remove row pattern
        test -f $set.pgm && continue
        test "$msg" && echo $msg && msg=""
        AIdark $set
        test $? -ne 0 && return 255
    done
    (test -z "$TASKMODE" || test "$TASKMODE" == "statusall") &&
        for set in $slist; do test -f $set.pgm && dklist="$dklist $set.pgm"; done &&
        test "$dklist" &&
        (AIexamine -n MasterDark_and_Flat $dklist &
        sleep 3)
    
    # dark variation (using first dark as reference)
    msg="# Estimate dark variation ..."
    #pnmcombine dk06.pgm dk09.pgm dk11.pgm dk12.pgm dkmn.pgm     # T05 bias
    #pnmcombine dk01.pgm dk02.pgm dkmn.pgm
    tellist=$(AIsetinfo -c | grep -w d | awk '{printf("%s\n", tolower($12))}' | sort -u)
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for tel in $tellist
    do
        test -f dk.var10.$tel.pgm && continue
        test "$msg" && echo $msg && msg=""
        set - $(AIsetinfo -c | grep -w d | \
            awk -v t=$tel '{if(tolower($12)==t){print $0}}' | sort -n -k9,9 | tail -1)
        test -f dkmn.pgm && rm dkmn.pgm
        ln -s $1.pgm dkmn.pgm
        for set in $(AIsetinfo -c | grep -w d | \
            awk -v t=$tel '{if(tolower($12)==t){print $1}}')
        do
            bs=""
            dcrawopts=""
            test "$AI_CCDREGION" && dcrawopts="-R $AI_CCDREGION"
            ext=$(AIimlist -f $set "" raw 2>/dev/null | head -1 | sed -e 's/.*\.//g')

            # determine intensity scaling factor to stretch to full 16bit range
            # this is used by AIraw2gray in case of FITS images only
            scale=$(get_param camera.dat rawbits $set | awk '{if ($1!="-" && $1<16) print 2^(16-$1)}')

            # check if top-down image flipping is required
            flip=$(get_param camera.dat flip $set | awk '{if ($1=="1") print 1}')
            
            # options for raw image conversion
            opts=""
            test "$scale" && opts="-s $scale"
            test "$flip"  && opts=$(echo $opts "-f")

            for num in $(AI_EXCLUDE="" AIimlist -n $set "" raw)
            do
                echo "# computing diff for $num ($set $tel $scale)" >&2
                rfile=$(get_rawfile $num)
                AI_DCRAWPARAM="$AI_DCRAWPARAM $dcrawopts" \
                    AIraw2gray $opts $rfile | \
                    pnmccdred -m 10 -a 1000 -d dkmn.pgm - - | pnmsmooth > x.dk.pgm
                if [ -z "$bs" ]
                then
                    l=$(identify x.dk.pgm | cut -d " " -f3 | tr 'x' '\n' | sort -nr | head -1)
                    bs=64
                    test $l -lt 3000 && bs=32
                fi
                AIbgmap -q x.dk.pgm $bs 1
                add=$(AIstat x.dk.bgm1.pgm | awk '{printf("%.0f", 1000-$5)}')
                pnmccdred -a $add x.dk.bgm1.pgm $AI_TMPDIR/dk.$num.pgm
                rm x.dk.bgm1.pgm x.dk.bg.pgm x.dk.pgm
            done
        done
        montage -background '#03c003c003c0' -fill '#050005000500' -label '%t' \
            $AI_TMPDIR/dk.????.pgm -geometry +4+2 ppm: | ppm2gray - > dk.var10.$tel.pgm
        rm -f $AI_TMPDIR/dk.????.pgm dkmn.pgm
    done
    
    # dark noise estimation (per pixel)
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for set in $slist
    do
        nimg=$(AIsetinfo $set | awk '{print $9}')
        test $nimg -lt 12 && continue
        echo "# estimate dark noise in $set, nimg=$nimg"
        grep -v "^#" set.dat | awk -v s=$set '{
            if ($2==s) printf("%s n%s\n", $1, substr($0,7))}' > $AI_TMPDIR/x.nset.dat
        AI_SETS=$AI_TMPDIR/x.nset.dat AInoise n$set
        rm -f ndk??.mn.pgm
    done
    
    # show some stats of darks
    for set in $slist
    do
        nimg=$(AIsetinfo $set | awk '{print $9}')
        mn=$(AImstat -c $set.pgm | cut -d ' ' -f5)
        sd=""
        test -e n$set.sd.pgm && sd=$(AImstat -c n$set.sd.pgm | cut -d ' ' -f5)
        LANG=C printf "$set n=%2d mean=$mn" $nimg
        test "$sd" && LANG=C printf " sd=$sd"
        printf "\n"
    done

    (test -z "$TASKMODE" || test "$TASKMODE" == "statusall") &&
        (AIexamine -n "Dark_Variation" -l dk.var10.*pgm &
        sleep 3)
    return 0
}

_flats () {
    local slist
    local fflist
    local texp
    local tel
    local cam
    local type
    local badpix
    local set
    slist=$(AIsetinfo -b | awk '{if($4=="f"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    echo "# Creating master flats ..."
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for set in $slist
    do
        texp=$(AIsetinfo $set | awk '{printf("%.0f", $8)}')
        tel=$(AIsetinfo $set | awk '{printf("%s", $12)}')
        cam=$(get_param camera.dat camera $tel | awk '{print tolower($1)}')
        echo "# tel=$tel  cam=$cam"
        type=long; test $texp -lt 32 && type=short
        badpix=hotpix.${cam}_$type.dat
        test ! -e $badpix &&
            echo "WARNING: file $badpix is missing." && badpix=""
        echo "# AI_BADPIX=\"$badpix\" AIflat $AO_FLATS -b $set"
        AI_BADPIX="$badpix" AIflat $AO_FLATS -b $set
        test $? -ne 0 && return 255
    done
    # statistics
    for set in $slist
    do
        test ! -f $set.pgm &&
            echo "WARNING: flat $set.pgm does not exist" &&
            continue
        AIstat -b -c $set.pgm
    done
    # show normalized flat image
    if [ -z "$TASKMODE" ] || [ "$TASKMODE" == "statusall" ]
    then
        for set in $slist
        do
            test ! -f $set.pgm && continue
            AIbnorm $set.pgm > $AI_TMPDIR/$set.norm.pgm
            fflist="$fflist $AI_TMPDIR/$set.norm.pgm"
        done
        test "$fflist" && AIexamine -n MasterDark_and_Flat $fflist &
        sleep 3
    fi
    return 0
}

_lights () {
    local slist
    local set
    local nlist1
    local nlist2
    local num
    local texp
    local tel
    local cam
    local type
    local ccdopts
    local badpix
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    echo "# Calibrating light frames ..."

    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") &&
    for set in $slist
    do
        # check if all images have been calibrated already
        nlist1=$(AIimlist -q -n $set 2>/dev/null | sort)    # processed
        nlist2=$(AIimlist -q -x -n $set | sort)             # all
        test "$nlist1" == "$nlist2" &&
            echo "WARNING: all images in $set are calibrated already" &&
            continue
            
        ccdopts="$AO_LIGHT"
        test -z "$ccdopts" && if echo "Mayhill SSO Nerpio Bathurst" | grep -w -q $AI_SITE
        then
            ccdopts="-a 100"
        else
            ccdopts="-q 1"
            texp=$(AIsetinfo $set | awk '{printf("%.0f", $8)}')
            tel=$(AIsetinfo $set | awk '{printf("%s", $12)}')
            cam=$(get_param camera.dat camera $tel | awk '{print tolower($1)}')
            echo "# tel=$tel  cam=$cam"
            type=long; test $texp -lt 32 && type=short
            badpix=hotpix.${cam}_$type.dat
            test ! -e $badpix &&
                echo "WARNING: file $badpix is missing." && badpix=""
        fi
        
        echo "# running: AI_BADPIX=\"$badpix\" AIccd $ccdopts $set"
        AI_BADPIX="$badpix" AIccd $ccdopts $set
        test $? -ne 0 && return 255
    done
    return 0
}

_bgvar () {
    local slist
    local bgcol
    local suffix
    local set
    local inext
    local bg
    local fg
    local nlist
    local num
    local filter
    local f
    local add
    local imlist
    local tellist
    local tel
    local title
    local doit
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        echo "WARNING: no images to process." && return 0
    echo "# Estimate background variation ..."

    sleep 3
    if [ -z "$TASKMODE" ] || [ "$TASKMODE" == "nodisplay" ]
    then
        # recognize already processed set
        test ! -s bgdiff.dat && doit=1
        for set in $slist
        do
            nlist="$nlist $(AIimlist -q -n $set "" "" o)"
        done
        if [ "${nlist// /}" ]
        then
            for num in $nlist
            do
                test "$doit" && continue
                AIsetinfo -b | grep -w o | awk '{printf("%s", $8)}' | \
                    grep -q -w $num && continue
                ! grep -q "^"$num"." bgdiff.dat && doit=1            
            done
        fi
        
        # check if bad region masks/images are black-and-white
        if [ "$doit" ] && [ -d "bgvar" ]
        then
            for num in $nlist
            do
                test -e bgvar/$num.bad.png &&
                    ! is_mask bgvar/$num.bad.png white &&
                    return 255
            done
        fi
    
        if [ "$doit" ]
        then
            for set in $slist
            do
                AIbgdiff -k -a -p $AO_BGVAR "$setname" >> bgdiff.dat
                test $? -ne 0 && return 255
                #AIbgdiff -k -a le01 >> bgdiff.dat
                #AIbgdiff -k "" 64 >> bgdiff.dat    # small images
            done
        fi
    fi
    test $(head -1 bgdiff.dat | wc -w) -gt 14 && bgcol=16   # rgb in 15 16 17
    test $(head -1 bgdiff.dat | wc -w) -eq 7  && bgcol=7    # gray in 7
    tellist=$(AIsetinfo -o | grep -v "^#" | awk '{printf("%s\n", tolower($12))}' | sort -u)
    test "$TASKMODE" != "nodisplay" && for tel in $tellist
    do
        nlist=""
        for set in $(AIsetinfo -o | grep -v "^#" | \
            awk -v t=$tel '{if(tolower($12)==t){print $1}}')
        do
            nlist="$nlist $(AIimlist -x -q -n $set)"
        done
        test -z "${nlist// /}" && continue
        filter=""
        for num in $nlist
        do
            test "$filter" && filter="$filter|"
            filter="${filter}^$num"
        done
        title="$tel: Average background per image"
        grep -wE "$filter" bgdiff.dat | AIplot -o $AI_TMPDIR/x.$tel.bg.png -t "$title" -p - 2 $bgcol
    done
    
    # show changing gradient only
    #suffix=bgdiff   # result of surface fit to AIbgmap of diff image excl. bad regions
    suffix=bgm1     # AIbgmap of diff image
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for set in $slist
    do
        set - $(AIsetinfo $set)
        test $9 -le 1 && continue
        inext="pgm"; test -f $AI_TMPDIR/$4.ppm && inext="ppm"
        bg='#03D003D003D0'
        fg='#042004200420'
        nlist=$(AIimlist -n $set)
        test -z "$nlist" && continue
        for num in $nlist
        do
            f=bgvar/$num.$suffix.$inext
            test -f $f || continue
            imcrop $f 70 > tmp1.$$.$inext
            add=$(AIstat tmp1.$$.$inext | awk -v m=1000 '{
                printf("%d",m-$5); if(NF>8) printf(",%d,%d", m-$9, m-$13)}')
            echo $num $f $add
            pnmccdred -a $add $f - | pnmscale 4 - > z.$set.$num.$inext
        done
        # note: montage changes intensities when output is 16bit grayscale
        montage -background $bg -fill $fg -label '%t' \
            z.$set.????.$inext -geometry +4+2 ppm: | ppm2gray - 0,1,0 > var$suffix.$set.$inext
        rm z.$set.????.$inext tmp1.$$.$inext
    done
    imlist=$(for set in $slist
        do
            if [ -f var$suffix.$set.ppm ]
            then
                echo var$suffix.$set.ppm
            else
                test -f var$suffix.$set.pgm && echo var$suffix.$set.pgm
            fi
        done)
    (test -z "$TASKMODE" || test "$TASKMODE" == "statusall") && test "$imlist" &&
        AIexamine -n "Background_Variation" -l $imlist &
    return 0
}

_register () {
    local slist
    local set
    local tellist
    local tel
    local nlist
    local xlist
    local failedlist
    local num
    local filter
    local title
    local retval=0
    
    # if necessary set AI_TELESCOPE to a matching entry in camera.dat
    #for set in le01 co03; do AI_TELESCOPE=GSO AIsource $set; done
    #AI_TELESCOPE=GSO
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    echo "# Source extraction and registration ..."
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for set in $slist
    do
        AIsource $set
        if [ $? -eq 0 ]
        then
            # if fwhm varies a lot (ratio >2) then increase number of bright stars to "-n 500"
            #AIregister -p au01 | tee -a reg.dat
            # rewrite AIregister using: type rvm | (head -1 ; dd of=/dev/null)
            AIregister $AO_REGIS $set | tee -a reg.dat
            test ${PIPESTATUS[0]} -ne 0 && retval=255
            test "$AI_DEBUG" && echo "DEBUG: AI_VERSION=$AI_VERSION retval=$retval"

            # find images where registration failed, e.g. due to large center offset
            # and try registration using relaxed constraints on allowed offsets
            nlist=""; failedlist=""
            nlist=$(grep -v "^#" reg.dat | awk '{if($10==-2) print $1}')
            xlist=$(grep -v "^#" reg.dat | awk '{if($10==-2) print $2}' | sort -u)
            if [ "$nlist" ]
            then
                echo "# WARNING: some images did not match, trying with relaxed constraints"
                #cp -p reg.dat reg.dat.orig
                failedlist=$(for x in $xlist; do
                    grep -v "^#" set.dat | grep -w o | grep -w $x | awk -v x=$x '{if($8==x){print $2}}'
                    done)
                for num in $nlist
                do
                    rm -f measure/$num.src.head
                    sed -i '/^'$num' /d' reg.dat
                done
                for set in $failedlist
                do
                    AIregister -m 0.6 -p $set "" 0.06 | tee -a reg.dat
                    test ${PIPESTATUS[0]} -ne 0 && retval=255
                done
            fi

        else
            retval=255
        fi
    done
    
    # show diagnostic plots
    tellist=$(AIsetinfo -o | grep -v "^#" | awk '{printf("%s\n", tolower($12))}' | sort -u)
    test "$TASKMODE" != "nodisplay" && for tel in $tellist
    do
        nlist=""
        for set in $(AIsetinfo -o | grep -v "^#" | \
            awk -v t=$tel '{if(tolower($12)==t){print $1}}')
        do
            echo $slist | grep -qw $set || continue
            nlist="$nlist $(AIimlist -x -q -n $set)"
        done
        test -z "$(echo $nlist)" && continue
        filter=""
        for num in $nlist
        do
            test "$filter" && filter="$filter|"
            filter="${filter}^$num"
        done
        title="$tel: FWHM in pixel"
        grep -wE "$filter" reg.dat | AIplot -o $AI_TMPDIR/x.$tel.fwhm.png -t "$title" -p - 1 7
        # mag difference (lower values = fainter than average)
        title="$tel: Mag difference to reference image"
        grep -wE "$filter" reg.dat | AIplot -o $AI_TMPDIR/x.$tel.dmag.png -t "$title" -p - 1 10
    done
    return $retval
}

_stack () {
    # GUI program options may be passed by env variable AO_STACK
    local stackopts
    local ctype="average"
    local rtype="bilinear"
    local retval=0
    local tellist
    local tel
    local slist
    local set
    local bopts
    local img
    local ext
    local str
    local target
    local filter
    local bgcol
    local bgg
    local fwhm
    local object
    local telid
    local bin
    local bgoff
    local imlist
    local x
    
    # normal stacking for all sets (default: resampling_type lanczos3)
    # DSLR with fwhm < 2.8pix use: -r bilinear
    # CCD  with fwhm < 2.5pix use: -r bilinear
    # TODO: exclude some outliers where AIregister might have failed, e.g.
    #   where nmag=0
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Stacking images ..."
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for set in $slist
    do
        test $retval -ne 0 && continue
        test "$msg" && echo $msg && echo "# AI_EXCLUDE=$AI_EXCLUDE" && msg=""
        # TODO: improve checking of existing stack, improve warning message
        test -e $set.head &&
            echo "WARNING: output header file $set.head already exists" &&
            continue

        tel=$(get_telescope $set | awk '{printf("%s\n", tolower($0))}')
        test -z "$tel" &&
            echo "WARNING: unknown telid for set $set, skipping set." &&
            continue
        bopts=""
        test -e badpix.$tel.png && bopts="$bopts -bad badpix.$tel.png" &&
            echo "# using badpix.$tel.png"
        stackopts="$AO_STACK"
        echo "# running: AIstack" $stackopts $bopts "-t $ctype -r $rtype $set"
        AIstack $stackopts $bopts -t $ctype -r $rtype $set
        test $? -ne 0 && retval=255
        test "$stackopts" && set_header $set.head AO_STACK="$stackopts"
    done

    false && (
    tellist=$(AIsetinfo -b | grep -v "^#" | awk '{printf("%s\n", tolower($11))}' | sort -u)
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for tel in $tellist
    do
        bopts=""
        test -e badpix.$tel.png && bopts="$bopts -bad badpix.$tel.png" &&
            echo "# using badpix.$tel.png"
        tslist=$(AIsetinfo -b -o | awk -v t=$tel '{if(tolower($11)==t){printf("%s ", $2)}}')
        for set in $tslist
        do
            test $retval -ne 0 && continue
            echo $slist | grep -qw $set || continue
            test "$msg" && echo $msg && echo "# AI_EXCLUDE=$AI_EXCLUDE" && msg=""
            # TODO: improve checking of existing stack, improve warning message
            test -e $set.head &&
                echo "WARNING: output header file $set.head already exists" &&
                continue
            #test ${set:0:2} == "sk" && ctype=median
            stackopts="$AO_STACK"
            echo "# running: AIstack" $stackopts $bopts -t $ctype -r $rtype $set
            AIstack $stackopts $bopts -t $ctype -r $rtype $set
            test $? -ne 0 && retval=255
            test "$stackopts" && set_header $set.head AO_STACK="$stackopts"
        done
    done
    )
    
    # statistics (image quality)
    echo "# Stack properties:"
    echo "#set   object   telid  bin  bgg  bgoff fwhm/pix  rms  site"
    for set in $slist
    do
        img=""; ext=""; str=""
        test -f $set.pgm && img=$set.pgm && ext="pgm"
        test -f $set.ppm && img=$set.ppm && ext="ppm"
        if [ -z "$ext" ]
        then
            test -f ${set}_md.pgm && img=${set}_md.pgm && ext="pgm"
            test -f ${set}_md.ppm && img=${set}_md.ppm && ext="ppm"
        fi
        test -z "$ext" && continue
        target=$(AIsetinfo -b $set | head -1 | awk '{printf("%s",$3)}')
        nlist=$(AIimlist -x -q -n $set 2> /dev/null)
        test -z "$nlist" && continue
        filter="^"$(echo $nlist | sed -e 's, ,\|^,g')
        
        # bgg fwhm object
        bgcol=16; test $ext == "pgm" && bgcol=7
        bgg=$(get_header -q $set.head AI_BGG)
        test -z "$bgg" && test -f bgdiff.dat &&
            bgg=$(grep -E "$filter" bgdiff.dat | mean - $bgcol | awk '{printf("%.0f", $1)}') &&
            set_header $set.head AI_BGG=$bgg
        if [ -f $set.$ext ]
        then
            test -f $set.src.dat || AIsource -q $set.$ext
            fwhm=$(get_header -q $set.head AI_FWHM)
            test -z "$fwhm" &&
                fwhm=$(sexselect -s $set.src.dat  "" 0.03 1000 2>&1 | \
                    grep FWHM | awk '{printf("%.1f", $2)}') &&
                set_header $set.head AI_FWHM=$fwhm
            object=$(get_header -q $set.head OBJECT | sed -e 's/^ *//; s/ *$//')
            if [ "$object" ]
            then
                str=" # orig. OBJECT=$object"
                test "$object" == "$target" && str=""
            else
                set_header $set.head OBJECT=$target
            fi
        else
            fwhm=$(grep -E "$filter" reg.dat | mean - 7)
        fi
        
        # telid binning bgoff rms
        telid=$(get_header -q $set.head AI_TELID)
        if [ -z "$telid" ]
        then
            telid=$(get_telescope -q $set)
            if [ "$telid" ]
            then
                set_header $set.head AI_TELID=$telid
            else
                telid="-"
            fi
        fi
        bin=$(get_header -q $set.head BINNING)
        test -z "$bin" && bin=$(get_header -q $set.head XBINNING)
        if [ "$bin" ]
        then
            set_header $set.head BINNING=$bin
        else
            bin=1
        fi
        bgoff=$(get_header -q $set.head AI_BGOFF)
        test -z "$bgoff" &&
            echo "Mayhill SSO Nerpio Bathurst" | grep -w -q $AI_SITE &&
            bgoff=100 &&
            set_header $set.head AI_BGOFF=$bgoff
        test -z "$bgoff" && bgoff=0
        rms=$(get_header -q $set.head AI_RMSG)
        test -z "$rms" &&
            rms=$(AIbg $img 10 | awk '{printf("%.1f", $2)}') &&
            set_header $set.head AI_RMSG=$rms
        
        x=$(get_header -q $set.head AI_SITE)
        test -z "$x" && set_header $set.head AI_SITE=$AI_SITE
        LANG=C printf "%-6s %-8s %-6s %d   %4.0f  %3d   %5.1f  %6.1f  %s$str\n" \
            $set $target $telid $bin $bgg $bgoff $fwhm $rms $AI_SITE
    done
    
    # display stacked images
    imlist=$(for set in $slist
        do
            ext="pgm"; test -f $set.ppm && ext="ppm"
            test -f $set.$ext && echo $set.$ext
        done)
    (test -z "$TASKMODE" || test "$TASKMODE" == "statusall") &&
        test "$imlist" && AIexamine $imlist &

    return $retval
}

_astrometry () {
    # algorithm:
    # - check for coordinates
    # - if not found, try to get comet ephemerides
    # - if not found or AI_NPA is unknown, run solve-field and AIwcs
    # notes about optional env variables to control program
    #   AO_AMASK - source mask, either name of a ds9 region file or
    #       a number representing max radius from image center to use
    #   AO_ACCOO - image center coordinates (RA,DEC) overwriting the
    #       values determined by imcoord automatically
    local slist
    local use_scat=1
    local set
    local ststack
    local line
    local ra
    local dec
    local do_solve_field
    local pixscale
    local binning
    local opts
    local north
    local catalog
    local maglim
    local thres
    local x
    local msg
    local cpulim
    local wcsopts
    local amask
    local rlim
    local wcslog=wcs/astrometry.log
    local retval=0
    local tdir=${AI_TMPDIR:-"/tmp"}
    local tmpfits=$(mktemp "$tdir/tmp_im_XXXXXX.fits")
    local tmpcat=$(mktemp "$tdir/tmp_scat_XXXXXX.fits")
    local tmpxy=$(mktemp "$tdir/tmp_xy_XXXXXX.fits")
    local tmpmask=$(mktemp "$tdir/tmp_mask_XXXXXX.reg")
    
    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Astrometric calibration ..."
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for set in $slist
    do
        test $retval -ne 0 && continue
        echo "$msg" && msg=""
        echo "set=$set"
        ststack=""
        test -f $set.pgm && ststack=$set.pgm
        test -f $set.ppm && ststack=$set.ppm
        test -z "$ststack" && continue
        test ! -e $set.head &&
            echo "WARNING: missing header file $set.head" && continue
        # skip processing if wcs header exists and there is no change in AO_AMASK
        amask=$(get_header -q $set.head AO_AMASK)
        test -f $set.wcs.head &&
            test "$AO_AMASK" == "$amask" &&
            echo "WARNING: WCS header file already exists." && continue
        test -d wcs || mkdir wcs
        echo -e "\nset=$set" >> $wcslog
        test "$AO_AMASK" && echo "# AO_AMASK=$AO_AMASK" | tee -a $wcslog
        
        # determine pixscale
        pixscale=""
        binning=""
        test -z "$binning" && binning=$(get_header -q $set.head BINNING)
        test -z "$binning" && binning=$(get_header -q $set.head XBINNING)
        test -z "$binning" && binning=1
        pixscale=$(get_param camera.dat pixscale $set | \
            awk -v b=$binning '{print $1*b}')
        test -z "$pixscale" &&
            error "unknown pixscale in $set"

        # check for image center coordinates
        do_solve_field=""
        if [ "$AO_ACCOO" ]
        then
            line=${AO_ACCOO/,/ }
        else
            line=$(imcoord $set 2>/dev/null)
            if [ $? -ne 0 ]
            then
                # get ephemerides
                #get_mpcephem -w $set 2>/dev/null
                #test $? -ne 0 &&
                    do_solve_field=1 &&
                    echo "WARNING: missing (approx.) field coordinates in $set.head" >&2
            fi
        fi
        
        # check for north angle
        north=$(get_header -q $set.head AI_NPA)
        test $? -ne 0 && do_solve_field=1
        
        
        # run solve-field if necessary
        opts=""
        if [ "$do_solve_field" ]
        then
            ! type -p solve-field > /dev/null &&
                error "program solve-field (astrometry.net) is not installed."

            # search radius on the sky
            radius=$(imsize $ststack | awk -v p=$pixscale '{printf("%.1f", 0.5*sqrt($1*$1+$2*$2)*p/3600)}')
            cpulim=300
            test ${radius%.*} -gt 4 && cpulim=600
            
            # using approx center coordinates in solve-field
            if [ "$(echo $line)" ]
            then
                set - $line
                opts="--ra $1 --dec $2 --radius $radius"
            fi
            # range of pixel scales to check (+-10%)
            opts="$opts "$(echo $pixscale | awk -v t=10 '{
                x=1+t/100
                printf("-L %.1f -H %.1f -u app", $1/x-0.1, $1*x+0.1)}')

            # run solve-field
            tmpsolve="tmp_${set}_solve_$RANDOM"
            if [ "$use_scat" ]
            then
                set - $(imsize $ststack)
                opts="$opts -w $1 -e $2 -X XWIN_IMAGE -Y YWIN_IMAGE -s MAG_AUTO -a"
                echo "# running: solve-field -O -p -l $cpulim $opts $tmpxy" | tee -a $wcslog
                sleep 3
                test ! -e $set.src.dat && AIsource -q $ststack
                x=""
                is_ppm $ststack && x="-2"
                rlim=""
                test "$AO_AMASK" && is_number "$AO_AMASK" && rlim=$AO_AMASK
                sexselect -f $x $set.src.dat "" 0.03 "$rlim" "" "" 99 > $tmpcat
                stilts tcopy ifmt=fits ofmt=fits-basic in=$tmpcat"#2" out=$tmpxy
                x=""
                test "$rlim" && x="(limited to r<$rlim pix)"
                echo "# $(get_header $tmpxy NAXIS2) sources" $x | tee -a $wcslog
                solve-field -O -o $tmpsolve -p -l $cpulim $opts $tmpxy >> $wcslog
            else
                echo "# running: solve-field -O -p -l $cpulim $opts $tmpfits" | tee -a $wcslog
                sleep 3
                imcrop $ststack 70 | ppm2gray -f - > $tmpfits
                solve-field -O -o $tmpsolve -p -l $cpulim $opts $tmpfits >> $wcslog
            fi
            test $? -ne 0 &&
                echo "ERROR: solve-field failed for $set" >&2 && retval=255
            test $retval -eq 0 && if [ -s $tdir/$tmpsolve.wcs ]
            then
                wcsinfo $tdir/$tmpsolve.wcs > x.wcsinfo
                set - $(grep -wE "^orientation|^ra_center_hms|^dec_center_dms" x.wcsinfo)
                echo "# writing to $set.head: RA=$4 DEC=$6"
                set_header $set.head RA="$4" DEC="$6"
                north=$(echo $2 | awk '{print -1*$1}')
                mv $tdir/$tmpsolve.wcs wcs/$set.an.wcs &&
                    (cd $tdir; rm -f $tmpsolve.* ${tmpsolve}-indx.xyls) &&
                    rm x.wcsinfo
            else
                echo "ERROR: solve-field failed for $set" >&2 && retval=255
            fi
        fi
        test $retval -ne 0 && continue
        
        # determine density of sources
        set - $(sdensity -q -a $set) x
        test $# -ne 4 &&
            echo "ERROR: unable to determine star density." >&2 && return 255
        dens=$1; nsrc=$2; area=$3
        
        # choose sensible parameters for AIwcs
        catalog="ucac4"; maglim=""; thres=10
        test ${area%.*} -gt 2 && maglim=15.5
        test ${area%.*} -gt 5 && catalog="ppmx" && maglim=14.5
        test ${area%.*} -gt 10 && maglim=13.5
        test ${area%.*} -gt 20 && maglim=13
        test ${area%.*} -gt 40 && maglim=12
        test ${area%.*} -gt 80 && maglim=11
        test $nsrc -gt 2000 && thres=20
        test $nsrc -gt 5000 && thres=30
        test $nsrc -gt 12000 && thres=40
        test $nsrc -gt 10000 && maglim=$(echo $maglim 16 | awk '{print $1-0.5}')
        test $nsrc -gt 25000 && maglim=$(echo $maglim 16 | awk '{print $1-0.5}')

        # options for AIwcs
        opts=""
        test -z "$north" && north=$(get_header -q $set.head AI_NPA)
        test "$north" && opts="-n $north"
        if [ "$AO_AMASK" ]
        then
            if [ -e $AO_AMASK ] && is_reg $AO_AMASK
            then
                opts="$opts -m $AO_AMASK"
                set_header $set.head AO_AMASK=$AO_AMASK
            else
                if is_number $AO_AMASK
                then
                    imsize $ststack | awk '{printf("center %d %d\n", $1/2, $2/2)}' | \
                        xy2reg $ststack - "" "" $AO_AMASK > $tmpmask
                    opts="$opts -m $tmpmask"
                    set_header $set.head AO_AMASK=$AO_AMASK
                else
                    echo "WARNING: cannot handle AO_AMASK=$AO_AMASK"
                fi
            fi
        fi
        
        # running AIwcs
        echo "# running: AIwcs $opts $set $catalog \"$maglim\" $thres" | tee -a $wcslog
        AIwcs $opts $set $catalog "$maglim" $thres >> $wcslog 2>&1
        test $? -ne 0 && retval=255 &&
            echo "ERROR: AIwcs failed (see $wcslog)" &&
            test -e $set.wcs.head && mv $set.wcs.head x.$set.wcs.failed.head
        # TODO: if AIwcs failed check ncat: e.g. get_header -e LDAC_OBJECTS wcs/sa01.ucac-4.dat NAXIS2
        #   if it is > 3*nimg limit to 2*nimg, otherwise limit to 40% of ncat
        #   unfortunately the catalog file does not fill the mag column (it is always 0)
    done
    
    # display results
    msg="# Summary for astrometry:
# set  xrms    yrms     nimg  ncat nmatch nhigh"
    x=""
    for set in $slist
    do
        test -f $set.wcs.head || continue
        test "$msg" && echo "$msg" && msg=""
        echo $(get_header -s $set.wcs.head ASTRRMS1,ASTRRMS2,NIMG,NCAT,NMATCH,NHIGH) | \
            awk -v s=$set '{
                printf("%s:  %.3f\"  %.3f\"", s, $1*3600, $2*3600)
                if(NF==6) {
                    printf("  %5d %5d  %5d %5d\n", $3, $4, $5, $6)
                } else {
                    printf("\n")
                }}'
        x="$x $(echo $(ls -1 wcs/$set.*.png))"
    done
    test "$TASKMODE" != "nodisplay" &&
        test "$x" && display $x &
    test $retval -eq 0 && rm -f $tmpfits $tmpcat $tmpxy $tmpmask
    return $retval
}

_costack () {
    local stackopt
    local slist
    local set
    local msg
    local ext
    local params
    local val
    local oxy
    local omove

    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Stacking on comet ..."
    (test -z "$TASKMODE" || test "$TASKMODE" == "nodisplay") && for set in $slist
    do
        test ! -f $set.head && continue
        ext=""
        test -f $set.pgm && ext="pgm"; test -f $set.ppm && ext="ppm"
        test -z "$ext" && continue
        test -f ${set}_m.$ext && continue
        test "$msg" && echo $msg && echo "# AI_EXCLUDE=$AI_EXCLUDE" && msg=""
        
        # get ephemerides
        get_mpcephem -w $set 2>/dev/null
        test $? -ne 0 &&
            echo "WARNING: cannot get comet ephemerides for $set ($target)"

        # check for astrometric calibration
        test ! -f $set.wcs.head &&
            echo "ERROR: missing astrometric calibration for $set" && return 255

        params=""
        val=$(get_header $set.head BADPIX);   test "$val" && params="-bad $val"
        val=$(get_header $set.head RESAMPT1); test "$val" && params="$params -r $val"
        set - $(get_header -q -s $set.head AI_CORA,AI_CODEC,AI_OMOVE) xx
        test $# -ne 4 &&
            echo "# skipping $set (missing comet header keywords)" >&2 && continue
        oxy=$(echo $set $1 $2 | rade2xy - $set.wcs.head | awk '{printf("%.0f,%.0f", $2, $3)}')
        omove=$3
        # if necessary add -bz 5000
        stackopt=$(get_header -q $set.head AO_STACK)
        echo "# running: AIstack" $stackopt $params -o \"_m\" -c $set.$ext -m $omove@$oxy $set
        AIstack $stackopt $params -o "_m" -c $set.$ext -m $omove@$oxy $set
        test $? -ne 0 && return 255
        
        # setting some header keywords
        set_header ${set}_m.head OBJECT=$target
        set_header $set.head AI_COMST=${set}_m.$ext
    done
    return 0
}


#------------------------------------
#   comet extraction and photometry
#------------------------------------

_load_stacks () {
    local slist
    local set
    local msg
    local ststack
    local costack
    local ext
    local idststack
    local idcostack

    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" && return
    msg="# Launch SAOImage AIRTOOLS ..."
    (test -z "$TASKMODE" || test "$TASKMODE" == "normal") && for set in $slist
    do
        #test $retval -ne 0 && continue
        #echo "$msg"
        msg=""
        ststack=""
        ext=""
        test -f $set.pgm && ststack=$set.pgm && ext="pgm"
        test -f $set.ppm && ststack=$set.ppm && ext="ppm"
        test -z "$ststack" &&
            error "missing star stack for set $set"
        test ! -e $set.head &&
            error "missing header file $set.head"
        #test ! -f $set.wcs.head &&
        #    echo "WARNING: missing WCS header file $set.wcs.head"
        costack=$(get_header $set.head AI_COMST)
        #test -z "$costack" &&
        #    echo "WARNING: missing comet stack for set $set"
        test "$costack" && test ! -f $costack &&
            echo "WARNING: missing comet stack $costack for set $set"
        
        # check for bg subtracted images
        test -f ${ststack%.*}.bgs.$ext &&
            ststack=${ststack%.*}.bgs.$ext
        test "$costack" && test -f ${costack%.*}.bgs.$ext &&
            costack=${costack%.*}.bgs.$ext
        # TODO: replace corrupted header files
        test ! -e ${ststack%.*}".head" &&
            ln -s $set.head ${ststack%.*}".head"
        test "$costack" && test ! -e ${costack%.*}".head" &&
            ln -s $set.head ${costack%.*}".head"

        # check for running SAOImage AIRTOOLS
        xpaaccess -c -t "2,2" AIRTOOLS > /dev/null
        if [ $? -eq 0 ]
        then
            # start SAOImage and load frames
            echo "# loading $ststack $costack ..."
            AIexamine $ststack $costack &
            idstack=$(wait_for_frame $ststack)
        else
            # append frames to a runnung SAOImage if not already loaded
            idststack=$(get_frameno $ststack)
            test "$costack" && idcostack=$(get_frameno $costack)
            if [ -z "$idststack" ]
            then
                echo "# loading $ststack ..."
                AIexamine $ststack &
                idststack=$(wait_for_frame $ststack)
            fi
            test "$costack" && if [ -z "$idcostack" ]
            then
                echo "# loading $costack ..."
                AIexamine $costack &
                idcostack=$(wait_for_frame $costack)
            fi
            #echo "idststack=$idststack"
            xpaset -p AIRTOOLS frame $idststack
        fi
    done < set.dat
    return 0
}

_ds9cmd () {
    # note: all tasks related to comet photometry must start with set name or image
    #   image - bggradient
    #   set   - psfextract, cometextract, manualdata, photcal
    local set=$2
    local msg="# ds9cmd $@"
    local ststack
    local fid

    echo "$msg"
    # determine name of star stack
    test -f "$set" && ststack=$set
    if [ -z "$ststack" ]
    then
        ! is_setname "$set" &&
            error "unknown image set $set"
        test -f $set.bgs.ppm && ststack=$set.bgs.ppm
        test -z "$ststack" && test -f $set.bgs.pgm && ststack=$set.bgs.pgm
        test -z "$ststack" && test -f $set.ppm && ststack=$set.ppm
        test -z "$ststack" && test -f $set.pgm && ststack=$set.pgm
        test -z "$ststack" &&
            error "missing star stack for set $set"
        test ! -e $set.head &&
            error "missing header file $set.head"
    fi
    # check for running SAOImage AIRTOOLS
    xpaaccess -c -t "2,2" AIRTOOLS > /dev/null
    if [ $? -eq 0 ]
    then
        # load star stack
        echo "# loading $ststack ..."
        AIexamine $ststack &
        fid=$(wait_for_frame $ststack)
    fi

    false && (
    # display star stack
    fid=$(get_frameno $ststack)
    if [ -z "$fid" ]
    then
        echo "# loading $ststack ..."
        AIexamine $ststack &
        wait_for_frame $ststack
    else
        # activate frame $fid
        case "$1" in
            aladindss)
                xpaset -p AIRTOOLS frame $fid
                ;;
        esac
    fi
    )
    
    ds9cmd "$@"
    return $?
}

_remove () {
    local slist
    local set
    local msg
    local nlist
    local num
    local ext
    local f
    local tmp1=$(mktemp "/tmp/tmp1_$$_XXXXXX.dat")

    #slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$setname" && slist=$setname
    test -z "$slist" &&
        error "you must provide at least one set name."
    for set in $slist
    do
        AIsetinfo -b $set
    done
    for set in $slist
    do
        nlist="$nlist $(AI_EXCLUDE="" AIimlist -x -n $set)"
    done
    
    for num in $nlist
    do
        f=bgvar/$num.bgm1.ppm;   test -e $f && echo "rm $f"
        f=bgvar/$num.bgm1.pgm;   test -e $f && echo "rm $f"
        f=bgvar/$num.bgdiff.ppm; test -e $f && echo "rm $f"
        f=bgvar/$num.bgdiff.pgm; test -e $f && echo "rm $f"
        f=measure/$num.src.dat;  test -e $f && echo "rm $f"
        f=measure/$num.src.head; test -e $f && echo "rm $f"
        f=$AI_TMPDIR/$num.ppm;   test -e $f && echo "rm $f"
        f=$AI_TMPDIR/$num.pgm;   test -e $f && echo "rm $f"
    done | sort > $tmp1
    for num in $nlist
    do
        test -s bgdiff.dat && echo "sed -i '/^$num.bgdiff/d' bgdiff.dat"
        test -s bgsfit.dat && echo "sed -i '/^$num /d' bgsfit.dat"
        test -s reg.dat    && echo "sed -i '/^$num /d' reg.dat"
    done >> $tmp1
    if [ -s $tmp1 ]
    then
        echo "Run: bash $tmp1"
    else
        echo "No files to remove."
        rm $tmp1
    fi
    return 0
}


#-------------------------
#   miscellaneous tools
#-------------------------
__load_images () {
    # library function called by _imexa_calib and _imexa_raw
    # loading calibrated or raw images in SAOImage AIRTOOLS window
    # pass list of image numbers as arguments
    local raw   # if set use raw images instead of calibrated images
    test "$1" == "-r" && raw=1 && shift 1
    local slist
    local set
    local msg
    local imlist
    local n
    local first
    local last
    local fid
    local retval=0
    local tmp1=$(mktemp "/tmp/tmp1_$$_XXXXXX.dat")
    local tmp2=$(mktemp "/tmp/tmp2_$$_XXXXXX.dat")

    slist=$(AIsetinfo -b | awk '{if($4=="o"){print $2}}')
    test "$1" && is_setname $1 && slist=$1 && shift 1
    test -z "$slist" && rm -f $tmp1 $tmp2 && return
    msg="# Searching images ..."
    for set in $slist
    do
        test $retval -ne 0 && continue
        test "$msg" && echo $msg && msg=""
        test -z "$raw" && AIimlist $set >> $tmp2
        test    "$raw" && AIimlist $set "" raw >> $tmp2
    done
    ! test -s $tmp2 && echo "WARNING: no images found" >&2 &&
        rm -f $tmp1 $tmp2 && return
    # extract number and filename, sort unique entries
    cat $tmp2 | awk '{printf("%s %s\n", $2, $3)}' | sort -u > $tmp1
    if [ "$1" ]
    then
        mknlist $@ | sort > $tmp2
        test $? -ne 0 && return 255
        imlist=$(join $tmp1 $tmp2 | awk '{print $2}')
        test -z "$imlist" && echo "WARNING: no matching image numbers" >&2 &&
            rm -f $tmp1 $tmp2 && return
    else
        imlist=$(cat $tmp1 | awk '{print $2}')
    fi
    n=$(echo $imlist | wc -w)
    first=$(echo $imlist | awk '{print $1}')
    last=$(echo $imlist | awk '{print $NF}')
    echo "# Loading $n images ..."
    test ! -d bgvar && mkdir bgvar # to allow storage of bad region files

    # check for running SAOImage AIRTOOLS
    xpaaccess -c -t "2,2" AIRTOOLS > /dev/null
    if [ $? -eq 0 ]
    then
        # start SAOImage and load frames
        echo "# loading $ststack ..."
        AIexamine $imlist &
        fid=$(wait_for_frame $first)
    else
        # append frames to a runnung SAOImage
        AIexamine $imlist &
        fid=$(wait_for_frame $last)
    fi

    rm -f $tmp1 $tmp2
    return 0
}

_imexa_calib () {
    # examine calibrated images
    __load_images "$@"
}

_imexa_raw () {
    # examine raw images
    __load_images -r "$@"
}

_usercmd () {
    echo "# Execute: $usercmd" "$@"
    test "$AI_DEBUG" && echo "nargs=$#"
    $usercmd "$@"
    return $?
}


#-------------------------
#   diagnostic tools
#-------------------------
_status () {
    echo "# Processing info and diagnostic files ..."
    AIsetinfo -b
    test -e reg.dat && (
        AIplot -t "FWHM in pixel" -p reg.dat 7
        AIplot -t "Mag difference to reference image" -p reg.dat 10)

    TASKMODE="status" _stack
    TASKMODE="status" _astrometry
    return 0
}

_check () {
    echo "# running checks ..."
    echo "# PATH=$PATH"
    AIcheck
}

_args () {
    local i=1
    echo "# airtools-cli: args" $@
    while test "$1"
    do
        echo "$i:  _"$1"_"
        i=$((i+1))
        shift 1
    done

    echo "# AO_ARGS = _${AO_ARGS}_"
    test -z "$AO_ARGS" && return 0
    set - ${AO_ARGS}
    i=1
    while test "$1"
    do
        echo "$i:  _"$1"_"
        i=$((i+1))
        shift 1
    done
    return 0
}



#--------------------
#   get options
#--------------------
cmdline="$(basename $0) $@"  # preserve command line
verbose=0
projectdir=""
setname=""
quiet=""
usercmd=""
TASKMODE=""
OVERWRITE=""
while getopts hp:s:o:m:c:q c
do
    case $c in
        p)  projectdir="$OPTARG";;
        s)  setname="${OPTARG//,/ }";;
        o)  OVERWRITE=1;;
        m)  TASKMODE="$OPTARG";;
        c)  usercmd="$OPTARG";;
        q)  quiet=1;;
        h)  longhelp; echo; task="help";;
        \?) shorthelp; exit -1;;
    esac
done
shift `expr $OPTIND - 1`

# display additional info if requested
if [ "$task" == "help" ]
then
    echo "\
Available AIRTOOLS tasks:
Image reduction:
    imageinfo   - extract basic image info
    darks       - create master darks
    flats       - create master flats
    lights      - calibrate light images
    bgvar       - evaluate image background variation
    register    - register images
    stack       - stack images (on stars)
    costack     - stack images on comet

Comet extraction and photometry:
    load_stacks - load stacked images

Miscellaneous tools:
    imexa_calib - load calibrated images
    imexa_raw   - load raw images
    status      - check previous results"
    exit 0
fi
if [ "$TASKMODE" == "list" ]
then
    echo "\
available task modes:
    nodisplay   - skip display of new windows (images, plots)
    status      - show available results (measurements) only
    statusall   - like status but includes image display "
    exit 0
fi


#--------------------
#   get parameter
#--------------------
if [ $# -lt 1 ] && [ -z "$usercmd" ]
then
    shorthelp; exit -1
fi
task=$1
shift 1
test "$usercmd" && task="usercmd"


#--------------------
#   checkings
#--------------------
# check existence of projectdir
if [ "$projectdir" ]
then
    test ! -d "$projectdir" && error "projectdir $projectdir is missing."
    cd $projectdir
fi
test ! -e $rcfile && error "not a valid airtools project (missing .airtoolsrc)"

# start logging
exec > >(tee -a $log)
exec 2>&1
test -s $log && echo -e "\n" >> $log
test ! "$quiet" &&
    echo "#### starting $(basename $0) v$VERSION at $(date +'%Y-%m-%d %H:%M')"

 
# check presence of required parameter files
for f in sites.dat camera.dat
do
    test ! -e "$f" && error "Missing file $f."
done

# check presence of required environment variables
source $rcfile
for var in day AI_SITE AI_TMPDIR AI_RAWDIR
do
    test -z "$var" && error "Variable $var undefined."
done
test ! -d $AI_TMPDIR &&
    echo "# creating temp directory $AI_TMPDIR" &&
    mkdir -p $AI_TMPDIR
test ! -d "$AI_TMPDIR" &&
    error "temp directory $AI_TMPDIR is missing."
if [ ! -d "$AI_RAWDIR" ]
then
    if [ "$TASKMODE" == "status" ] || [ "$TASKMODE" == "statusall" ]
    then
        echo "WARNING: raw image directory $AI_RAWDIR is missing."
    else
        error "raw image directory $AI_RAWDIR is missing."
    fi
fi

airfun=$(which airfun.sh)
echo "# airfun=$airfun"
if [ -z "$airfun" ]
then
    error "missing function definition file airfun.sh
    (PATH=$PATH)"
fi
if [ "$airfun" == "./airfun.sh" ]
then
    echo "# PWD=$PWD"
    echo "# PATH=$PATH"
    echo "WARNING: loading functions from local file airfun.sh ..."
    sleep 10
else
    test ! "$quiet" && echo "# PATH=$PATH" && echo "# loading $airfun"
fi

. $airfun > /dev/null
test ! "$quiet" &&
    echo "# AI_VERSION=$AI_VERSION" &&
    echo "# dcraw-tl $(dcraw-tl | grep "[0-9]" | head -1 | awk '{print $NF}')"
! AIcheck_ok &&
    error "Unable to initialize AIRTOOLS functions."



#-----------------------
#   main program start
#-----------------------
trap "" PIPE
errcode=""

# get list of existing image sets from set.dat
setlist=""
test -e set.dat && setlist=$(grep -v "^#" set.dat | awk '{
    if ($1!~/^[0-9][0-9]:[0-9][0-9]/) next
    if ($4!="o") next
    if ($5!~/^[0-9]+$/) next
    if ($6!~/^[0-9]+$/) next
    if ($7!~/^[0-9]+$/) next
    if ($8!~/^[0-9]+$/) next
    if (NF<11) next
    printf(";%s (%s)", $2, $3)
    }')

# check for valid setname
test "${setname// /}" && for set in $setname
do
    ! is_setname $set && error "Unknown image set $set."
done

# Run task
test "$task" != "imageinfo" && test "$task" != "usercmd" &&
    test ! -e "set.dat" &&
    error "Missing file set.dat."

echo "# Running task $task ($(date +'%H:%M')) ..."
_$task "$@"
errcode=$?
test -z "$errcode" && error "Missing return code from task."
test "$errcode" == "0" && echo "# task finished at $(date +'%H:%M')"

exit $errcode
